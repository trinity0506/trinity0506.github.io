---
title: DFS算法的原理与应用
date: 2023-11-29 18:33:03
tags:
---
> 深度优先搜索算法（Depth First Search，简称DFS）：一种用于遍历或搜索树或图的算法。 沿着树的深度遍历树的节点，尽可能深的搜索树的分支。当节点v的所在边都己被探寻过或者在搜寻时结点不满足条件，搜索将回溯到发现节点v的那条边的起始节点。整个进程反复进行直到所有节点都被访问为止。属于盲目搜索,最糟糕的情况算法时间复杂度为O(!n)。

# 一、基本原理
1. 为求得某一问题的解，先选择某一可能情况向前探索；
2. 探索过程中，一旦发现原来的选择是错误的，就退一步重新选择，继续向前探索；
3. 如此反复进行，直至得到解或证明无解。

# 二、模板
C模板:
```c
int a[510]; //存储每次选出的数据
int book[510];  //标记是否被访问
int ans=0;  //记录符合条件的次数

void DFS(int cur){  
    if(cur==k){ //k个数已经选完，可以进行输出等相关操作
        for(int i=0;i<cur;i++){
            printf("%d",a[i]);
        }
        ans++;
        return ;
    }

    for(int i=0;i<k;i++){   //遍历n个数，并从中选择k个数
        if(!book[i]){   //若没有被访问
            book[i]=1;  //标记为已被访问
            a[cur]=i;   //选定本数，并加入数组
            DFS(cur+1); //递归，cur+1
            book[i]=0;  //释放，标记为未访问，方便下次引用
        }
    }   
}
```
代码过于抽象（对于笔者），下引用例题以方便理解

# 三、例题 
 
## 1.排列问题 

题目一:
设有n个整数的集合{1,2,...,n} 从中选出任意r个数进行排列，试列出所有排列 

实现过程：  

1. 定义两个数组a[]、book[]，其中a保存每次的排列数据，book保存i这个数是否被访问；
2. 初始化相关数据；
3. 递归填数并判断第i个数是否合法
    **合法**：填数，并判断是否已经到达环的终点。若到达终点，打印结果，否则，继续填下一个数；
    **不合法**：选择下一种可能。 

**AC代码：**
```cpp
#include<iostream>

using namespace std;
int n,r,ans;    //r个数进行排列，ans为排列个数
int book[510];  //标记是否被访问
int a[510];   //记录每次的排列数据

void DFS(int cur){  //从集合中取r个数构成的排列
    if(r==cur){ //已经取够r个数
        for(int i=0;i<cur;i++){ //循环输出
            cout<<a[i]<<' ';
        }
        cout<<endl;
        ans++   //数量加1
        return ;
    }
    
    for(int i=1;i<n;i++){   //保证循环不漏
        if(!book[i]){   //若没访问过
        book[i]=1;  //标记已访问
        a[cur]=i;   //i符合条件加入
        DFS(cur+1); //寻找一个数字
        book[i]=0;  //回溯，清除标记
        }
    }
}

int main(){
    cin>>n>>r;
    DFS(0);

    cout<<ans<<endl;
    return 0;
}
```
